---

## 1Ô∏è‚É£ Substring vs Subsequence (Very Important)

### Substring

* Characters must be **continuous**
* No skipping allowed

Example:

```
"bcd" is a substring of "abcde" ‚úÖ
"ace" is NOT ‚ùå
```

### Subsequence

* Order matters
* Skipping allowed

üìå Today is **only substring**.

---

## 2Ô∏è‚É£ Why Substring Needs Separate Study

Substring problems:

* care about **ranges**
* depend on **start & end**
* later use sliding window

If you don‚Äôt lock this now, window problems feel magic later.

---

## 3Ô∏è‚É£ Generating All Substrings (Brute Force)

This teaches **range thinking**.

### Logic

* Fix starting index `i`
* Extend ending index `j`

---

### Code

```python
s = "abc"

for i in range(len(s)):
    for j in range(i, len(s)):
        print(s[i:j+1])
```

‚è±Ô∏è Time: O(n¬≤)
üì¶ Space: O(1)

---

## 4Ô∏è‚É£ Key Observation (Exam / Interview Gold)

Number of substrings of length `n`:

```
n * (n + 1) / 2
```

So substring problems:

* **cannot** be better than O(n¬≤) unless optimized logically

---

## 5Ô∏è‚É£ Checking if a Substring Exists (Naive)

Problem:

> Check if `pat` exists in `text`

### Logic

* Try matching from every index
* Stop early if mismatch

---

### Code

```python
def is_substring(text, pat):
    n, m = len(text), len(pat)

    for i in range(n - m + 1):
        if text[i:i+m] == pat:
            return True

    return False
```

---

## 6Ô∏è‚É£ Why This Topic Matters

This prepares you for:

* sliding window
* pattern matching
* string constraints
* optimization thinking

Without this, later topics feel random.

---

## üß™ Practice Problems 

1. Print all substrings of a string
2. Count total substrings
3. Check if pattern exists in text
4. Difference between substring & subsequence (write in README)

