
---

## 1ï¸âƒ£ Why Strings Need Separate Attention

Strings look simple but:

* characters are **not numbers**
* indexing still exists
* frequency logic changes slightly

Almost every string problem starts with:
ğŸ‘‰ **character frequency**

---

## 2ï¸âƒ£ Character Hashing Using Array (Fixed Alphabet)

If string contains only:

* lowercase letters `aâ€“z`

You can map:

```
a â†’ 0
b â†’ 1
...
z â†’ 25
```

### Code

```python
s = "abbcaa"
freq = [0] * 26

for ch in s:
    freq[ord(ch) - ord('a')] += 1
```

â±ï¸ Time: O(n)
ğŸ“¦ Space: O(1) (constant 26)

---

## 3ï¸âƒ£ Character Hashing Using Dictionary (General Case)

Use this when:

* uppercase + lowercase
* digits
* symbols

```python
freq = {}

for ch in s:
    freq[ch] = freq.get(ch, 0) + 1
```

ğŸ“Œ This is more flexible but uses extra space.

---

## 4ï¸âƒ£ Common String Frequency Problems

Once freq is ready, problems become easy:

* count characters
* find repeating characters
* find non-repeating characters
* compare two strings

Hashing does **80% of the work**.

---

## 5ï¸âƒ£ First Non-Repeating Character (Classic)

### Logic

1. Build frequency
2. Traverse string again
3. First char with freq = 1

```python
for ch in s:
    if freq[ch] == 1:
        print(ch)
        break
```

---

## 6ï¸âƒ£ Key Observations (Important)

* Strings are arrays of characters
* Hashing avoids nested loops
* Frequency â†’ decision â†’ answer

If a string question mentions:

> repeat, unique, anagram, count

Your instinct:
ğŸ”¤ **Character Hashing**

---

## ğŸ§ª Practice Problems 

1. Count frequency of characters
2. Print all repeating characters
3. First non-repeating character
4. Check if string has all unique characters

(Do NOT optimize further yet.)

---


