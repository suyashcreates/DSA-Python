
## 1ï¸âƒ£ Multiple Recursion (More than one recursive call)

### Definition

When a function calls itself **more than once** in the same function body.

Example:

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

Here:

* Each call creates **two more calls**
* Tree-like recursion structure

---

## 2ï¸âƒ£ Recursion Tree Visualization

For `fib(4)`:

```text
fib(4)
 â”œâ”€ fib(3)
 â”‚   â”œâ”€ fib(2)
 â”‚   â”‚   â”œâ”€ fib(1)
 â”‚   â”‚   â””â”€ fib(0)
 â”‚   â””â”€ fib(1)
 â””â”€ fib(2)
     â”œâ”€ fib(1)
     â””â”€ fib(0)
```

ğŸ“Œ Key Insight:
Same subproblems are solved **again and again**

This is why recursion can be slow.

---

## 3ï¸âƒ£ Time Complexity of Multiple Recursion

### Fibonacci example:

```text
T(n) = T(n-1) + T(n-2) + O(1)
```

* TC â‰ˆ **O(2â¿)** (exponential)
* SC = **O(n)** (stack depth)

ğŸ“Œ Rule:

> If recursion branches â†’ expect exponential time unless optimized

---

## 4ï¸âƒ£ Overlapping Subproblems (Important Concept)

When the **same recursive call** appears multiple times.

Example:

* `fib(2)` is calculated multiple times
* `fib(1)` and `fib(0)` repeat heavily

ğŸ“Œ This concept leads to **Dynamic Programming** later
(Donâ€™t implement DP yet â€” just understand the issue)

---

## 5ï¸âƒ£ Stack Overflow (Why it happens)

Stack overflow occurs when:

* Base case is missing
* Base case is wrong
* Recursion depth is too large

Example:

```python
def infinite(n):
    print(n)
    infinite(n+1)
```

ğŸ“Œ Python recursion limit â‰ˆ **1000 calls**

---

## 6ï¸âƒ£ Recursion vs Iteration (Conceptual Difference)

### Recursion

* Uses **call stack**
* Cleaner logic
* Higher space usage

### Iteration

* Uses loops
* Lower space
* Sometimes harder to think

Example: Factorial

**Recursive**

```python
def fact(n):
    if n == 0:
        return 1
    return n * fact(n-1)
```

**Iterative**

```python
def fact(n):
    res = 1
    for i in range(1, n+1):
        res *= i
    return res
```

ğŸ“Œ Interviews may ask:

> â€œCan you convert recursion to iteration?â€

---

## 7ï¸âƒ£ When to Use Recursion (Rule of Thumb)

Use recursion when:

* Problem has **natural substructure**
* Tree / divide-type logic
* Clean base case exists

Avoid recursion when:

* Very deep calls
* Simple loops can do the job

---

## ğŸ§ª Practice Problems 

### Problem 1: Count number of recursive calls

```python
def fun(n):
    if n == 0:
        return
    fun(n-1)
    fun(n-1)
```

ğŸ“Œ Calls = **2â¿ âˆ’ 1**

---

### Problem 2: Print all subsequences of a string (thinking only)

```python
def subseq(s, i, curr):
    if i == len(s):
        print(curr)
        return
    subseq(s, i+1, curr)
    subseq(s, i+1, curr + s[i])
```

ğŸ“Œ TC: **O(2â¿)**
ğŸ“Œ SC: **O(n)**

(No optimization, just understanding)

---

### Problem 3: Power function

```python
def power(x, n):
    if n == 0:
        return 1
    return x * power(x, n-1)
```

ğŸ“Œ TC: O(n)
ğŸ“Œ SC: O(n)

---

## ğŸ BONUS: Interview Thinking Rule

Before writing recursion, say aloud:

1. What does **one call do**?
2. What is the **smallest input**?
3. How many times will this function be called?

If you canâ€™t answer â†’ donâ€™t code yet.

---


