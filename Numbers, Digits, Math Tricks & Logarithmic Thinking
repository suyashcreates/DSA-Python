
Build strong control over number-based problems, understand digit manipulation, recognize
logarithmic patterns, and apply math optimizations used heavily in DSA and interviews.
 Digits in a Number (Core Building Block)
Extract Last Digit
d = n % 10
Remove Last Digit
n = n // 10
These two operations are the backbone of all digit problems.

 Constructing Numbers Digit by Digit
Build a Number
num = 0
num = num * 10 + digit
Used in: - Reverse number - Palindrome - Base conversions
 Count Digits Efficiently

Method 1: Loop (Safe)

count = 0
while n > 0:
count += 1
n //= 10
TC → O(digits)

Method 2: Logarithm
import math
digits = int(math.log10(n)) + 1
TC → O(1)
 Works only for n > 0
 Logarithmic Time Complexity (Recognition Skill)

Key Rule
If the input divides by a constant, TC is logarithmic.
while n > 1:
n //= 2
 TC = O(log n)

This appears in: - Binary search - GCD - Digit counting
 Factors & √n Optimization

Naive Approach
for i in range(1, n+1):
if n % i == 0:
print(i)
TC → O(n)

Optimized Approach
for i in range(1, int(n**0.5) + 1):
if n % i == 0:
print(i, n//i)
TC → O(√n)
 Factors come in pairs.
 Euclidean Algorithm (GCD)

Recursive Version
def gcd(a, b):
if b == 0:
return a
return gcd(b, a % b)

Complexity
TC → O(log n)
SC → O(log n) (recursion stack)

This is one of the most important math algorithms.

 Practice Problems 
Problem 1: Reverse a Number
Problem 2: Check Palindrome Number
Problem 3: Count Digits (Loop & Log Method)
Problem 4: Print All Factors (Optimized)
Problem 5: GCD Using Euclidean Algorithm

 Bonus (Interview Thinking)
Digit problems → usually O(digits)
Math optimization reduces brute force
log n often hides inside division loops
Always think: Can I reduce iterations?
